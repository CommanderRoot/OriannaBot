import fetch from "node-fetch";
import {
    EphemeralInteractionFollowupWebhookResponse,
    InitialInteractionWebhookResponse,
    Response,
    ResponseOptions,
    TextChannelResponse
} from "./response";
import * as eris from "eris";

/**
 * A response context represents some way for a command to reply to an invocation,
 * regardless of whether that invocation was done through a message or through a
 * slash command. In general, this allows for indicating activity (typing), replying
 * directly (which may have different behavior depending on whether this is the first
 * reply or a different one) and replying discreetly (either through a DM or by
 * sending an ephemeral message).
 *
 * Note that the response context should keep track of the responses created, such
 * that they can be disposed of or cleaned up when needed.
 */
export abstract class ResponseContext {
    /**
     * Acknowledge that we have received the message and are
     * currently processing it. This should not result in visual
     * activity.
     */
    public abstract acknowledgeReceival(): Promise<void>;

    /**
     * Indicate that we are currently working on processing the
     * command, usually by indicating typing in the channel.
     */
    public abstract indicateProgress(): Promise<void>;

    /**
     * Indicate that we've responded to the message, by either reacting to
     * message with a checkmark or editing the message to indicate we've acknowledged it.
     */
    public abstract acknowledgeProcessed(message: string): Promise<void>;

    /**
     * Create a new textual response in the same channel as where the
     * initial command invocation took place.
     */
    public abstract createResponse(options: ResponseOptions): Promise<Response>;

    /**
     * Create a new private response, either through ephemeral messages (if
     * available) or by sending the author a private message. Note that if the
     * author does not have private messages enabled, this may error.
     */
    public abstract createPrivateResponse(options: ResponseOptions): Promise<Response>;

    /**
     * Handle the given reaction add event, passing it to responses if desirable.
     * This will only be invoked if `freeResponses` has not yet been called.
     */
    public abstract processReactionEvent(event: dissonance.ReactionAddEvent): Promise<void>;

    /**
     * Delete all of the responses sent by this context, if possible. This should
     * never error, even when deleting failed.
     */
    public abstract deleteResponses(): Promise<void>;

    /**
     * Perform all the actions needed in order for this context to become garbage
     * collectible. Generally, this consists of removing reaction listeners and
     * attempting to clean up the reactions themselves. This method is automatically
     * invoked after roughly 15 minutes have passed, since that is the default
     * lifetime of interaction tokens generated by slash commands.
     */
    public abstract freeResponses(): Promise<void>;

    /**
     * Shorthands for various colored messages.
     */
    public readonly ok = (response: ResponseOptions = {}) => this.createResponse({ color: 0x49bd1a, ...response });
    public readonly error = (response: ResponseOptions = {}) => this.createResponse({ color: 0xfd5c5c, ...response });
    public readonly info = (response: ResponseOptions = {}) => this.createResponse({ color: 0x0a96de, ...response });
}

/**
 * A response context that simply sends messages normally in a given channel.
 * The channel can either be a text channel in a guild, or a private DM with
 * the user.
 */
export class ChannelResponseContext extends ResponseContext {
    private responses: TextChannelResponse[] = [];

    constructor(private channelId: string, private user: dissonance.User | null, private bot: eris.Client, private originalMessageId?: string) {
        super();
    }

    async acknowledgeReceival(): Promise<void> {
        // Nothing to do.
    }

    async indicateProgress(): Promise<void> {
        await this.bot.sendChannelTyping(this.channelId);
    }

    async acknowledgeProcessed(message: string): Promise<void> {
        if (!this.originalMessageId) return;

        await this.bot.addMessageReaction(this.channelId, this.originalMessageId, "✅").catch(() => {});
    }

    async createPrivateResponse(options: ResponseOptions): Promise<Response> {
        if (!this.user) throw new Error("Cannot create private response if original invocation user is unknown.");

        // Acknowledge through a checkmark.
        if (this.originalMessageId) {
            this.bot.addMessageReaction(this.channelId, this.originalMessageId, "✅").catch(() => {
            });
        }

        const privateChannel = await this.bot.getDMChannel(this.user.id);
        const response = new TextChannelResponse(privateChannel.id, this.bot, this.user);
        this.responses.push(response);
        return response.reply(options);
    }

    createResponse(options: ResponseOptions): Promise<Response> {
        const response = new TextChannelResponse(this.channelId, this.bot, this.user || undefined);
        this.responses.push(response);
        return response.reply(options);
    }

    async deleteResponses(): Promise<void> {
        await Promise.all(this.responses.map(x => x.remove()));
        this.responses = [];
    }

    async freeResponses(): Promise<void> {
        await Promise.all(this.responses.map(x => x.removeAllOptions()));
        this.responses = [];
    }

    async processReactionEvent(event: dissonance.ReactionAddEvent): Promise<void> {
        await Promise.all(this.responses.map(x => x.processReactionEvent(event)));
        return Promise.resolve(undefined);
    }
}

/**
 * A response context for some message that was sent through a slash-command interaction.
 */
export class InteractionResponseContext extends ResponseContext {
    private firstResponse: InitialInteractionWebhookResponse | null = null;
    private responses: Response[] = [];

    constructor(private channelId: string, private user: dissonance.User, private bot: eris.Client, private interactionId: string, private token: string) {
        super();
    }

    async acknowledgeReceival(): Promise<void> {
        await fetch(`https://discord.com/api/v9/interactions/${this.interactionId}/${this.token}/callback`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                type: 5
            })
        });
    }

    async indicateProgress(): Promise<void> {
        // Nothing to do.
    }

    async acknowledgeProcessed(message: string): Promise<void> {
        await this.createResponse({
            color: 0x49bd1a,
            title: message
        });
    }

    async createPrivateResponse(options: ResponseOptions): Promise<Response> {
        // Delete old pending response.
        await fetch(`https://discord.com/api/v9/webhooks/${this.bot.user.id}/${this.token}/messages/@original`, {
            method: "DELETE",
            headers: {
                "Content-Type": "application/json"
            }
        });

        // Create ephemeral one.
        const response = new EphemeralInteractionFollowupWebhookResponse(this.channelId, this.bot, this.user, this.token);
        this.responses.push(response);
        return response.reply(options);
    }

    createResponse(options: ResponseOptions): Promise<Response> {
        if (!this.firstResponse) {
            this.firstResponse = new InitialInteractionWebhookResponse(this.channelId, this.bot, this.user, this.token);
            return this.firstResponse.reply(options);
        }

        const response = new TextChannelResponse(this.channelId, this.bot, this.user);
        this.responses.push(response);
        return response.reply(options);
    }

    async deleteResponses(): Promise<void> {
        if (this.firstResponse) await this.firstResponse.remove();
        await Promise.all(this.responses.map(x => x.remove()));
        this.firstResponse = null;
        this.responses = [];
    }

    async freeResponses(): Promise<void> {
        if (this.firstResponse) await this.firstResponse.removeAllOptions();
        await Promise.all(this.responses.map(x => x.removeAllOptions()));
        this.firstResponse = null;
        this.responses = [];
    }

    async processReactionEvent(event: dissonance.ReactionAddEvent): Promise<void> {
        if (this.firstResponse) await this.firstResponse.processReactionEvent(event);
        await Promise.all(this.responses.map(x => x.processReactionEvent(event)));
        return Promise.resolve(undefined);
    }
}